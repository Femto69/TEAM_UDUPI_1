# -*- coding: utf-8 -*-
"""sih_aqi

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18F3RJ5kdq_k26UE4vSh-yS8R3gDdNy7d
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score, GridSearchCV
from sklearn.ensemble import RandomForestRegressor
from sklearn.tree import DecisionTreeRegressor
from xgboost import XGBRegressor
from sklearn.metrics import mean_absolute_error as mae
from sklearn.metrics import mean_squared_error as mse

data1 = pd.read_csv('/content/deli_aqi_date.zip')
data2 = pd.read_csv('/content/delhi_aqi_weather.zip')
data3 = pd.read_csv('/content/archive (1).zip')

data1.head()

data1.tail()

data1['datetime'] = pd.to_datetime(data1['date'])
data1['Date_1'] = data1['datetime'].dt.date
data1['year'] = data1['datetime'].dt.year
data1['month'] = data1['datetime'].dt.month
data1['Day'] = data1['datetime'].dt.day
data1['Weekday'] = data1['datetime'].dt.day_name()   # Converting the 'date' column to datetime
data1['hour'] = data1['datetime'].dt.hour          # Extracting the hour

data1.head()

def season_creation(x):
    if x in [2,3,4]:
        season = "Spring"
    elif x in [5,6]:
        season = "Summer"
    elif x in [7,8]:
        season = "Monsoon"
    elif x in [9,10]:
        season = "Autumn"
    elif x in[11,12,1]:
        season = "Winter"
    return season

data1["Season"] = data1["month"].apply(season_creation)
data1.head()

data4 = data1.groupby('Date_1')[['co','no', 'no2', 'o3', 'so2', 'pm2_5', 'pm10', 'nh3']].mean().reset_index()
data4.head()
data4['Date'] = pd.to_datetime(data4['Date_1'])
data4.info()
print(type('Date'))
data4['year'] = data4['Date'].dt.year
data4['month'] = data4['Date'].dt.month
data4['Day'] = data4['Date'].dt.day
data4['Weekday'] = data4['Date'].dt.day_name()   # Converting the 'date' column to datetime
       # Extracting the hour
data4.drop(['Date_1'],axis=1,inplace=True)
data4["Season"] = data4["month"].apply(season_creation)
data1.head()
data4.head()

data4.tail()

data2.head()



data2.drop(['Unnamed: 0'],axis=1,inplace=True)
data2.columns= ['avg temp','max temp','min temp','pressure','humidity','visibility' ,'avg wind speed','max wind speed' , 'aqi']
mean_value = data2['aqi'].mean()
data2['aqi'] = data2['aqi'].fillna(mean_value)
data2.head()

X = data2['aqi']
Y = data2['visibility']
print(X,Y)
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, random_state=3)
model = XGBRegressor()
model.fit(X_train, y_train)
test_pred = model.predict(X_test)
mean_abs_error = mae(y_test, test_pred)
print(mean_abs_error)

p = data4['pm2_5']
P = np.array(p)
visibility_pred = model.predict(P.reshape(-1, 1))
data4['visibility'] = visibility_pred
data4.head()

specific_date = '2021-11-11'
readings = data4[data4['Date'] == specific_date]
print(readings)

def calculate_value1(pm10):
    if isinstance(pm10, str):  # Check if pm2_5 is a string
        return 0
    elif pm10 <= 50:
        return pm10 # Assuming c8 is pm2_5 itself (or replace with the correct value)
    elif 50 < pm10 <= 100:
        return pm10  # Assuming c8 is pm2_5 itself (or replace with the correct value)
    elif 100 < pm10 <= 250:
        return 100 + (pm10 - 100) * 100 / 150
    elif 250 < pm10 <= 350:
        return 200 + (pm10 - 250)
    elif 350 < pm10 <= 430:
        return 300 + (pm10 - 350) * (100 / 80)
    elif pm10 > 430:
        return 400 + (pm10 - 430) * (100 / 80)
data4['pm10_sub_index'] = data4['pm10'].apply(calculate_value1)
data4.head()

def calculate_value2(pm2_5):
    if isinstance(pm2_5, str):  # Equivalent to ISTEXT in Excel
        return 0
    elif pm2_5 <= 30:
        return pm2_5 * 50 / 30
    elif 30 < pm2_5 <= 60:
        return 50 + (pm2_5 - 30) * 50 / 30
    elif 60 < pm2_5 <= 90:
        return 100 + (pm2_5 - 60) * 100 / 30
    elif 90 < pm2_5 <= 120:
        return 200 + (pm2_5 - 90) * (100 / 30)
    elif 120 < pm2_5 <= 250:
        return 300 + (pm2_5 - 120) * (100 / 130)
    elif pm2_5 > 250:
        return 400 + (pm2_5 - 250) * (100 / 130)
data4['pm2.5_sub_index'] = data4['pm2_5'].apply(calculate_value2)
data4.head()

def calculate_value3(c12):
    if isinstance(c12, str):  # Equivalent to ISTEXT in Excel
        return 0
    elif c12 <= 40:
        return c12 * 50 / 40
    elif 40 < c12 <= 80:
        return 50 + (c12 - 40) * 50 / 40
    elif 80 < c12 <= 380:
        return 100 + (c12 - 80) * 100 / 300
    elif 380 < c12 <= 800:
        return 200 + (c12 - 380) * (100 / 420)
    elif 800 < c12 <= 1600:
        return 300 + (c12 - 800) * (100 / 800)
    elif c12 > 1600:
        return 400 + (c12 - 1600) * (100 / 800)
data4['pm_so2_sub_index'] = data4['so2'].apply(calculate_value3)
data4.head()

def calculate_value4(c14):
    if isinstance(c14, str):  # Equivalent to ISTEXT in Excel
        return 0
    elif c14 <= 40:
        return c14 * 50 / 40
    elif 40 < c14 <= 80:
        return 50 + (c14 - 40) * 50 / 40
    elif 80 < c14 <= 180:
        return 100 + (c14 - 80) * 100 / 100
    elif 180 < c14 <= 280:
        return 200 + (c14 - 180) * (100 / 100)
    elif 280 < c14 <= 400:
        return 300 + (c14 - 280) * (100 / 120)
    elif c14 > 400:
        return 400 + (c14 - 400) * (100 / 120)
data4['pm_no2_sub_index'] = data4['no2'].apply(calculate_value4)
data4.head()

def calculate_value5(c16):
    if isinstance(c16, str):  # Equivalent to ISTEXT in Excel
        return 0
    elif c16/1000 <= 1:
        return c16/1000 * 50 / 1
    elif 1 < c16/1000 <= 2:
        return 50 + (c16/1000 - 1) * 50 / 1
    elif 2 < c16/1000 <= 10:
        return 100 + (c16/1000 - 2) * 100 / 8
    elif 10 < c16/1000 <= 17:
        return 200 + (c16/1000 - 10) * (100 / 7)
    elif 17 < c16/1000 <= 34:
        return 300 + (c16/1000 - 17) * (100 / 17)
    elif c16/1000 > 34:
        return 400 + (c16/1000 - 34) * (100 / 17)
data4['pm_co_sub_index'] = data4['co'].apply(calculate_value5)
data4.head()

def calculate_value6(c18):
    if isinstance(c18, str):  # Equivalent to ISTEXT in Excel
        return 0
    elif c18 <= 50:
        return c18 * 50 / 50
    elif 50 < c18 <= 100:
        return 50 + (c18 - 50) * 50 / 50
    elif 100 < c18 <= 168:
        return 100 + (c18 - 100) * 100 / 68
    elif 168 < c18 <= 208:
        return 200 + (c18 - 168) * (100 / 40)
    elif 208 < c18 <= 748:
        return 300 + (c18 - 208) * (100 / 539)
    elif c18 > 748:
        return 400 + (c18 - 748) * (100 / 539)
data4['pm_o3_sub_index'] = data4['o3'].apply(calculate_value6)
data4.head()

def calculate_value7(c20):
    if isinstance(c20, str):  # Equivalent to ISTEXT in Excel
        return 0
    elif c20 <= 200:
        return c20 * 50 / 200
    elif 200 < c20 <= 400:
        return 50 + (c20 - 200) * 50 / 200
    elif 400 < c20 <= 800:
        return 100 + (c20 - 400) * 100 / 400
    elif 800 < c20 <= 1200:
        return 200 + (c20 - 800) * (100 / 400)
    elif 1200 < c20 <= 1800:
        return 300 + (c20 - 1200) * (100 / 600)
    elif c20 > 1800:
        return 400 + (c20 - 1800) * (100 / 600)
data4['pm_nh3_sub_index'] = data4['nh3'].apply(calculate_value7)
data4.head()

print(data4.columns.tolist())
data4.columns = data4.columns.str.strip()
# Ensure all columns exist
required_columns = ['pm10_sub_index', 'pm2.5_sub_index', 'pm_so2_sub_index',
                    'pm_no2_sub_index', 'pm_co_sub_index', 'pm_o3_sub_index',
                    'pm_nh3_sub_index']

for col in required_columns:
    if col not in data4.columns:
        print(f"Column {col} is missing or incorrectly named!")

data4.head()

def calculate_max_value(row):
    e8 = row['pm10_sub_index']
    e10 = row['pm2.5_sub_index']
    e12 = row['pm_so2_sub_index']
    e14 = row['pm_no2_sub_index']
    e16 = row['pm_co_sub_index']
    e18 = row['pm_o3_sub_index']
    e20 = row['pm_nh3_sub_index']
    d8 = row['pm10_sub_index']
    d10 = row['pm2.5_sub_index']
    d12 = row['pm_so2_sub_index']
    d14 = row['pm_no2_sub_index']
    d16 = row['pm_co_sub_index']
    d18 = row['pm_o3_sub_index']
    d20 = row['pm_nh3_sub_index']

    #if (e8 == 1 or e10 == 1) and (e8 + e10 + e12 + e14 + e16 + e18 + e20) >= 3:
    return max(d8, d10, d12, d14, d16, d18, d20)
     # Or any other default value if the condition is not met
data4['aqi'] = data4.apply(calculate_max_value, axis=1)
data4.head()

data4.columns

data7 = data4[['Date','aqi', 'visibility', 'Season' ,'year', 'month', 'Day', 'Weekday']]
data7.head()

data3.head()

data3.head()

data3.drop(['Year','Month','date'],axis=1,inplace=True)
data3.head()

data3['year'] = data3['Date'].dt.year
data3['month'] = data3['Date'].dt.month
data3['Day'] = data3['Date'].dt.day
data3['Weekday'] = data3['Date'].dt.day_name()
data3["Season"] = data3["month"].apply(season_creation)
data3.head()

start_date = '2020-11-25'
end_date = '2023-01-24'

data5 = data3[(data3['Date'] >= start_date) & (data3['Date'] <= end_date)]
data5.head()



data5.tail()

data5.drop(['Max Dew Point','Avg Dew Point','Min Dew Point', 'Max Humidity', 'Min Humidity', 'Min Wind Speed', 'Max Pressure', 'Min Pressure', 'Total Precipitation'],axis=1,inplace=True)

data5.head()

data5.info()

def temp_f_to_C(temp_f):
    return (temp_f - 32) * 5/9

data5['Avg Temp'] = data5['Avg Temperature'].apply(temp_f_to_C)
data5['Max Temp'] = data5['Max Temperature'].apply(temp_f_to_C)
data5['Min Temp'] = data5['Min Temperature'].apply(temp_f_to_C)
data5.drop(['Avg Temperature','Max Temperature','Min Temperature'],axis=1,inplace=True)
data5.head()

def convert_inhg_to_hpa(pressure_inhg):
    # Conversion formula: 1 inhg = 33.8639 hPa
    return pressure_inhg * 33.8639

# Example usage with a DataFrame column
# Assuming your DataFrame is named 'data7' and has a column 'pressure_inhg'
data5['pressure_hpa'] = data5['Avg Pressure'].apply(convert_inhg_to_hpa)

# Display the first few rows
data5.head()
data5.drop(['Avg Pressure'],axis=1,inplace=True)
data5.head()

data8 = pd.merge(data7, data5, on='Date', how='outer')
data8.head()
data8.drop(['Season_x', 'year_x','Day_x', 'Weekday_x', 'month_x'],axis=1,inplace=True)
data8.head()

specific_date = '2020-11-25'
readings = data5[data5['Date'] == specific_date]
print(readings)

data8.isnull().sum()

mean_aqi = data8['aqi'].mean()  # Calculate the mean of the 'aqi' column
data8['aqi'].fillna(mean_aqi, inplace=True)  # Replace null values with the mean
mean_visibility = data8['visibility'].mean()  # Calculate the mean of the 'aqi' column
data8['visibility'].fillna(mean_visibility, inplace=True)  # Replace null values with the mean
mean_Avg_Humidity = data8['Avg Humidity'].mean()  # Calculate the mean of the 'aqi' column
data8['Avg Humidity'].fillna(mean_Avg_Humidity, inplace=True)  # Replace null values with the mean
mean_Max_Wind_Speed = data8['Max Wind Speed'].mean()  # Calculate the mean of the 'aqi' column
data8['Max Wind Speed'].fillna(mean_Max_Wind_Speed, inplace=True)  # Replace null values with the mean
mean_Avg_Wind_Speed = data8['Avg Wind Speed'].mean()  # Calculate the mean of the 'aqi' column
data8['Avg Wind Speed'].fillna(mean_Avg_Wind_Speed, inplace=True)  # Replace null values with the mean
mean_Avg_Temp = data8['Avg Temp'].mean()  # Calculate the mean of the 'aqi' column
data8['Avg Temp'].fillna(mean_Avg_Temp, inplace=True)  # Replace null values with the mean
mean_Max_max_temp = data8['Max Temp'].mean()  # Calculate the mean of the 'aqi' column
data8['Max Temp'].fillna(mean_Max_max_temp, inplace=True)  # Replace null values with the mean
mean_Min_temp = data8['Min Temp'].mean()  # Calculate the mean of the 'aqi' column
data8['Min Temp'].fillna(mean_Min_temp, inplace=True)  # Replace null values with the mean
mean_pressure_hpa = data8['pressure_hpa'].mean()  # Calculate the mean of the 'aqi' column
data8['pressure_hpa'].fillna(mean_pressure_hpa, inplace=True)  # Replace null values with the mean
data8.isnull().sum()

data8.drop(['month_y', 'year_y', 'Day_y', 'Weekday_y', 'Season_y'],axis=1,inplace=True)
data8.head()

data8['year'] = data8['Date'].dt.year
data8['month'] = data8['Date'].dt.month
data8['day'] = data8['Date'].dt.day
data8['weekday'] = data8['Date'].dt.weekday
data8.head()

data8["season"] = data8["month"].apply(season_creation)
data8.head()

df = data8.groupby('month')['visibility'].mean()
print(df)

df1 = data8.groupby('Date')['visibility'].mean()
print(df1)

data8.isnull().sum()

data8.info()

season_mapping = {
    'Spring': 0,
    'Summer': 1,
    'Monsoon': 2,
    'Autumn': 3,
    'Winter': 4
}
data8['season'] = data8['season'].map(season_mapping)
# Verify the encoding
print(data8['season'].head())

data8.info()

Y = data8['aqi']
X = data8.drop(['aqi', 'Date'],axis=1)
print(X,Y)

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=3)
print(X_train.shape, X_test.shape, Y_train.shape, Y_test.shape)
print(Y_train)

import numpy as np

# Check for NaN values
print(np.isnan(Y_train).sum())

# Check for infinity values
print(np.isinf(Y_train).sum())

# Check for excessively large values
print(Y_train.max())

model = XGBRegressor()

model.fit(X_train, Y_train)

test_pred = model.predict(X_test)
mean_abs_error = mae(Y_test, test_pred)
print(mean_abs_error)

model1 =RandomForestRegressor()

model1.fit(X_train, Y_train)

test_pred1 = model1.predict(X_test)
mean_abs_error1 = mae(Y_test, test_pred1)
print(mean_abs_error1)

!pip install catboost

from lightgbm import LGBMRegressor
from catboost import CatBoostRegressor
from sklearn.metrics import mean_absolute_error

# LightGBM
lgbm_model = LGBMRegressor()
lgbm_model.fit(X_train, Y_train)
lgbm_pred = lgbm_model.predict(X_test)
lgbm_mae = mean_absolute_error(Y_test, lgbm_pred)
print(lgbm_mae)
print('_______________________________________________')
# CatBoost
cat_model = CatBoostRegressor(verbose=0)
cat_model.fit(X_train, Y_train)
cat_pred = cat_model.predict(X_test)
cat_mae = mean_absolute_error(Y_test, cat_pred)
print(cat_mae)
print('_______________________________________________')

from sklearn.ensemble import StackingRegressor
from sklearn.linear_model import Ridge

# Example stacking with XGB, RF, and LGBM
estimators = [
    ('xgb', XGBRegressor()),
    ('rf', RandomForestRegressor()),
    ('lgbm', LGBMRegressor())
]
stacking_model = StackingRegressor(estimators=estimators, final_estimator=Ridge())
stacking_model.fit(X_train, Y_train)
stack_pred = stacking_model.predict(X_test)
stack_mae = mean_absolute_error(Y_test, stack_pred)
print(stack_mae)
print('_______________________________________________')

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

model = Sequential()
model.add(Dense(64, input_dim=X_train.shape[1], activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mean_absolute_error')

model.fit(X_train, Y_train, epochs=100, batch_size=32, verbose=0)
nn_pred = model.predict(X_test)
nn_mae = mean_absolute_error(Y_test, nn_pred)

print(nn_mae)
print('_______________________________________________' )

model3 = DecisionTreeRegressor()
model3.fit(X_train, Y_train)
test_pred3 = model3.predict(X_test)
mean_abs_error3 = mae(Y_test, test_pred3)
print(mean_abs_error3)

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.datasets import make_regression
from sklearn.ensemble import AdaBoostRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_absolute_error

# Initialize the base estimator (DecisionTreeRegressor)
base_estimator = DecisionTreeRegressor(max_depth=4)

# Initialize AdaBoost with the base estimator
adaboost = AdaBoostRegressor(base_estimator=base_estimator, n_estimators=50, random_state=42)

# Fit the model on the training data
adaboost.fit(X_train, Y_train)

# Make predictions on the test data
y_pred = adaboost.predict(X_test)

# Evaluate the model
mae = mean_absolute_error(Y_test, y_pred)
print(f'Mean Absolute Error: {mae:.2f}')

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.datasets import make_regression
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error

# Generate a sample regression dataset
X, y = make_regression(n_samples=1000, n_features=10, noise=0.1, random_state=42)

# Split the dataset into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and fit the Linear Regression model
model = LinearRegression()
model.fit(X_train, y_train)

# Make predictions on the test data
test_pred = model.predict(X_test)

# Evaluate the model
mean_abs_error = mean_absolute_error(y_test, test_pred)
print(f'Mean Absolute Error: {mean_abs_error:.2f}')

# Make predictions on the training data
train_pred = model.predict(X_train)

# Compute MAE for training data
train_mae = mean_absolute_error(y_train, train_pred)

# Compute MAE for test data
test_mae = mean_absolute_error(y_test, test_pred)

print(f'Training MAE: {train_mae:.2f}')
print(f'Test MAE: {test_mae:.2f}')

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming X is your feature matrix and y is your target variable

# Plotting scatter plots for each feature against the target variable
num_features = X.shape[1]

plt.figure(figsize=(15, 10))

for i in range(num_features):
    plt.subplot(num_features, 1, i + 1)
    plt.scatter(X[:, i], y, alpha=0.5)
    plt.title(f'Feature {i} vs Target')
    plt.xlabel(f'Feature {i}')
    plt.ylabel('Target')

plt.tight_layout()
plt.show()

data8.info()

# Convert columns to appropriate data types
df = data8.astype({
    'aqi': 'float',  # or 'int' if you prefer
    'visibility': 'float',
    'Avg Humidity': 'float',
    'Max Wind Speed': 'float',
    'Avg Wind Speed': 'float',
    'Avg Temp': 'float',
    'Max Temp': 'float',
    'Min Temp': 'float',
    'pressure_hpa': 'float',
    'year': 'int',
    'month': 'int',
    'day': 'int',
    'weekday': 'int',
    'season': 'int'
})

# Verify data types after conversion
print(df.dtypes)


features = [
    'visibility',
    'Avg Humidity',
    'Max Wind Speed',
    'Avg Wind Speed',
    'Avg Temp',
    'Max Temp',
    'Min Temp',
    'pressure_hpa',
    'year',
    'month',
    'day',
    'weekday',
    'season'
]

# Create a scatter plot for each feature vs. target
plt.figure(figsize=(15, 20))

for i, feature in enumerate(features):
    plt.subplot(len(features), 1, i + 1)
    sns.scatterplot(data=data8, x=feature, y='aqi')
    plt.title(f'{feature} vs AQI')
    plt.xlabel(feature)
    plt.ylabel('AQI')

plt.tight_layout()
plt.show()

