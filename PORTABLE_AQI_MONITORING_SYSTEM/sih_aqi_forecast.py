# -*- coding: utf-8 -*-
"""sih_aqi_forecast

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A3FjAgWmPDroLM6BQe_UrvUvfwh_mX8Z
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score, GridSearchCV
from sklearn.ensemble import RandomForestRegressor
from sklearn.tree import DecisionTreeRegressor
from xgboost import XGBRegressor
from sklearn.metrics import mean_absolute_error as mae
from sklearn.metrics import mean_squared_error as mse
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

data = pd.read_csv('/content/delhi_aqi[1].csv')

data.head()

data.shape

data.info()

df = data.copy()

# Ensure you are consistently using 'data' as the DataFrame variable
data['datetime'] = pd.to_datetime(data['date'])
data['Date_1'] = data['datetime'].dt.date
data['Year'] = data['datetime'].dt.year
data['month'] = data['datetime'].dt.month
data['Day'] = data['datetime'].dt.day
data['Weekday'] = data['datetime'].dt.day_name()   # Converting the 'date' column to datetime
data['hour'] = data['datetime'].dt.hour          # Extracting the hour

data.head()

def season_creation(x):
    if x in [2,3,4]:
        season = "Spring"
    elif x in [5,6]:
        season = "Summer"
    elif x in [7,8]:
        season = "Monsoon"
    elif x in [9,10]:
        season = "Autumn"
    elif x in[11,12,1]:
        season = "Winter"
    return season

data["Season"] = data["month"].apply(season_creation)
data.head()

plt.figure(figsize = (12,7))
sns.boxplot(x = data['Weekday'], y = data['pm2_5'], hue = data['Season'])
plt.show()

plt.figure(figsize = (12,7))
sns.boxplot(x = data['Weekday'], y = data['pm10'], hue = data['Season'])
plt.show()

list1 = ['co', 'no', 'no2', 'o3', 'so2', 'pm2_5', 'pm10', 'nh3']
plot = 1
plt.figure(figsize =(15,12))
for i in list1:
    plt.subplot(4,2,plot)
    sns.lineplot(x = data['Season'], y = data[i])
    plot = plot+1
plt.show()

plot = 1
plt.figure(figsize =(15,12))
for i in list1:
    plt.subplot(4,2,plot)
    sns.lineplot(x='hour', y = i, data = data, color = 'r')
    plot = plot+1
plt.show()

data.head()

df_pred = data[['Date_1','pm2_5']]
df_pred.head()

df_pred.info()

df_pred['Date'] = pd.to_datetime(df_pred['Date_1'])
df_pred.info()

df_pred = df_pred.groupby('Date')['pm2_5'].mean().reset_index()
df_pred.head()

df_pred1 = df_pred.copy()
df_pred1.set_index('Date', inplace=True)
print(df_pred1)
df_pred1.head(50)
df_pred1.tail()

df_pred1.describe()

df_pred1.plot()
plt.show()

import statsmodels.api as sm
sm.stats.durbin_watson(df_pred1)

from statsmodels.tsa.seasonal import seasonal_decompose

# Decompose the time series
decomposition_additive = seasonal_decompose(df_pred1, model='additive', period=1)
decomposition_additive.plot()
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose

# Decompose the time series
decomposition_additive = seasonal_decompose(df_pred1, model='additive', period=7)
decomposition_additive.plot()
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose

# Decompose the time series
decomposition_additive = seasonal_decompose(df_pred1, model='additive', period=365)
decomposition_additive.plot()
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose#breaks model into its components
from pylab import rcParams
rcParams['figure.figsize'] = 12,7
decomposition_additive = seasonal_decompose(df_pred1, model = 'additive', period=12)# additive measn sum of trend seasonality and residual where residual means outliers
decomposition_additive.plot()
plt.show()

from statsmodels.tsa.arima.model import ARIMA
# Ensure df_pred1 is a DataFrame with only the 'pm2_5' column and Date as the index


# Define the ARIMA model
model_arima = ARIMA(df_pred1[['pm2_5']], order=(5,1,1))  # order=(p,d,q)
model_arima_fit = model_arima.fit()

# Forecast

forecast_arima = model_arima_fit.forecast(steps=30)  # Forecast for 30 days
df_pred1['Forecast_ARIMA'] = model_arima_fit.predict(start=0, end=len(df_pred1)-1)# historical data pe prediction
print(forecast_arima)
print(df_pred1)

# Get the dates for the forecasted period
forecast_dates = pd.date_range(start=df_pred1.index[-1], periods=30, freq='D')

# Create a DataFrame to display the dates and forecasted AQI values
forecast_df = pd.DataFrame({'Date': forecast_dates, 'Predicted_AQI': forecast_arima})

# Display the DataFrame
print(forecast_df)
# Plot the results
df_pred1[['pm2_5', 'Forecast_ARIMA']].plot()
plt.title('ARIMA Model Forecast')
plt.show()

# Print model performance
print(model_arima_fit.summary())

from statsmodels.tsa.statespace.sarimax import SARIMAX

# Define the SARIMA model
model_sarima = SARIMAX(df_pred1['pm2_5'], order=(5,1,0), seasonal_order=(1,1,1,12))
model_sarima_fit = model_sarima.fit()

# Forecast
forecast_sarima = model_sarima_fit.forecast(steps=30)
df_pred1['Forecast_SARIMA'] = model_sarima_fit.predict(start=0, end=len(df_pred1)-1)
print(forecast_sarima)
print('---------------------------------------------')
print(df_pred1)
print('------------------------------------------------------')
# Get the dates for the forecasted period
forecast_dates = pd.date_range(start=df_pred1.index[-1], periods=30, freq='D')

# Create a DataFrame to display the dates and forecasted AQI values
forecast_df = pd.DataFrame({'Date': forecast_dates, 'Predicted_AQI': forecast_arima})

# Display the DataFrame
print(forecast_df)
print('------------------------------------------------------')
# Plot the results
df_pred1[['pm2_5', 'Forecast_SARIMA']].plot()
plt.title('SARIMA Model Forecast')
plt.show()

# Print model performance
print(model_sarima_fit.summary())

import prophet
from prophet import Prophet

# Prepare the data for Prophet
df_prophet = df_pred[['Date', 'pm2_5']].rename(columns={'Date': 'ds', 'pm2_5': 'y'})

# Define and fit the model
model_prophet = Prophet()
model_prophet.fit(df_prophet)

# Make future predictions
future = model_prophet.make_future_dataframe(periods=30)
forecast_prophet = model_prophet.predict(future)
print(forecast_prophet)
print('--------------------------------')
print(future)

forecast_df = pd.DataFrame({'Date': future['ds'], 'Predicted_AQI': forecast_prophet['yhat']})
print(forecast_df)
print('--------------------------------')
# Plot the results
model_prophet.plot(forecast_prophet)
plt.title('Prophet Model Forecast')
plt.show()

from sklearn.metrics import mean_absolute_error

# Calculate MAE for each model
mae_arima = mean_absolute_error(df_pred1['pm2_5'], df_pred1['Forecast_ARIMA'])
mae_sarima = mean_absolute_error(df_pred1['pm2_5'], df_pred1['Forecast_SARIMA'])
mae_prophet = mean_absolute_error(df_prophet['y'], forecast_prophet['yhat'][:len(df_prophet)])
#mae_lstm = mean_absolute_error(test, test_predict)

# Print the MAE for each model
print(f'MAE ARIMA: {mae_arima}')
print(f'MAE SARIMA: {mae_sarima}')
print(f'MAE Prophet: {mae_prophet}')
#print(f'MAE LSTM: {mae_lstm}')

import prophet

df_prophet = df_pred.rename(columns={'Date':'ds', 'pm2_5':'y'})                   # Renaming the column names according to Prophet's guidelines
df_prophet

from prophet import Prophet

m = Prophet()
model = m.fit(df_prophet)

model.seasonalities

future_data = model.make_future_dataframe(periods = 180, freq='D')
#add 180 dates freq = daily

future_data

df_prophet.shape

future_data.shape

prediction = model.predict(future_data)
prediction

prediction.columns

prediction[['ds','yhat_lower', 'yhat_upper', 'yhat']].tail(180)

model.plot(prediction)
plt.show()

model.plot_components(prediction)
plt.show()

!pip install pmdarima
!pip install statsmodels

from statsmodels.tsa.arima.model import ARIMA
from pmdarima import auto_arima
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

from statsmodels.tsa.stattools import adfuller
print(data)
result = adfuller(data['pm2_5'])
print(f'ADF Statistic: {result[0]}')
print(f'p-value: {result[1]}')

# Select only numeric columns
numeric_data = data.select_dtypes(include=[np.number])

# Apply differencing
df_diff = numeric_data.diff().dropna()

# Display the first few rows to check the output
df_diff.head()

